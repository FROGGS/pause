#!/usr/local/bin/perl -w -- -*- mode: cperl; cperl-indent-level: 4 -*-

# Some POD is after __END__

use strict;
use lib "/home/k/PAUSE/lib";
use CPAN::Checksums 1.016;
use Cwd ();
use Data::Dumper ();
use DirHandle ();
use ExtUtils::MakeMaker;
use ExtUtils::Manifest;
use File::Basename ();
use File::Copy ();
use HTTP::Date ();
use Mail::Send ();
use DBI;
use PAUSE ();
our $MLROOT = $PAUSE::Config->{MLROOT};
$MLROOT =~ s|/+$||; # I found the trailing slash annoying
use PAUSE::MailAddress ();
use CPAN; # only for CPAN::Version
use Text::Format;
use YAML ();
use Getopt::Long;
$Data::Dumper::Indent = 1;

{
    package PAUSE::mldistwatch;
    ###### data initialization ######
    use File::Path qw(rmtree mkpath);
    use vars qw($Id $ISAPERL);
    $Id = q$Id$;
    $ISAPERL = q{ perl-?5[._-](\\d{3}(_[0-4][0-9])?|\\d*[24680]\\.\\d+)\\.tar[._-]gz\\z };
}


package PAUSE::mldistwatch;
# this class shows that it was born as spaghetticode

sub new {
    my $class = shift;
    my $opt = shift;

    my $tarbin = "/usr/local/bin/tar";
    $tarbin = "/bin/tar" unless -x $tarbin;
    die "No tarbin found" unless -x $tarbin;

    my $unzipbin = "/usr/local/bin/unzip";
    $unzipbin = "/usr/bin/unzip" unless -x $unzipbin;
    die "No unzip found" unless -x $unzipbin;

    my $self = bless {
                      TARBIN => $tarbin,
                      UNZIPBIN  => $unzipbin,
                      OPT => $opt,
                     }, $class;
    $self->{VERBOSE} = -t STDOUT ? 2 : 1;
    $self;
}

sub verbose {
    my($self,$level,@what) = @_;
    unless (@what) {
        @what = ("warning: verbose called without \@what: ", $level);
        $level = 1;
    }
    return if $level > $self->{VERBOSE};
    unless (exists $self->{INTRODUCED}) {
        unshift @what, "Running $0, $Id\n";
        $self->{INTRODUCED} = undef;
    }
    print @what;
}

sub work {
    my $self = shift;
    my $startdir = Cwd::cwd();
    chdir $MLROOT
	or die "Couldn't chdir to $MLROOT";
    $self->init_all();
    $self->set_active_status();
    my $testdir = "/tmp/test" . $$; # XXX File::Temp!
    rmtree $testdir if -e $testdir;
    unless (mkpath $testdir) {
        die("Couldn't make directory $testdir: $!");
    }
    chdir $testdir
	or die("Couldn't change to $testdir: $!");
    {
        $self->checkfornew();
    }
    chdir $startdir;
    rmtree $testdir;
    return if $self->{OPT}{pick};
    $self->work2;
}

sub work2 {
    my $self = shift;
    $self->rewrite02();
    chdir $MLROOT
        or die "Couldn't chdir to $MLROOT: $!";
    $self->rewrite01();
    $self->rewrite03();
}

sub set_active_status {
    my $self = shift;
    my $db = $self->connect;
    my $active = $db->selectall_hashref("SELECT userid
                                         FROM users
                                         WHERE ustatus='active'",
                                        "userid");
    my %seen;
    my @new_active_users = grep { !$active->{$_} && !$seen{$_}++ }
        map { m|./../([^/]+)/| } keys %{$self->{ALLfound}};
    return unless @new_active_users;
    $self->verbose(2,"Info: new_active_users[@new_active_users]");
    my $sth = $db->prepare("UPDATE users
                            SET ustatus='active', ustatus_ch=NOW()
                             WHERE userid=?");
    for my $user (@new_active_users) {
        $sth->execute($user);
    }
    $sth->finish;
}

sub connect {
    my $self = shift;
    return $self->{DBH} if $self->{DBH};
    my $dbh = DBI->connect(
                           $PAUSE::Config->{MOD_DATA_SOURCE_NAME},
                           $PAUSE::Config->{MOD_DATA_SOURCE_USER},
                           $PAUSE::Config->{MOD_DATA_SOURCE_PW},
                           {
                            RaiseError => 1 }
                          ) or die $DBI::errstr;
    $self->{DBH} = $dbh;
}

sub disconnect {
    my $self = shift;
    return unless $self->{DBH};
    $self->{DBH}->disconnect;
    delete $self->{DBH};
}

sub DESTROY {
    my $self = shift;
    $self->disconnect;
}

sub init_all {
    my $self = shift;
    $self->verbose(2,"Running manifind\n");
    $self->{ALLfound} = ExtUtils::Manifest::manifind();
    $self->verbose(2,"Collecting distmtimes from DB\n");
    my $dbh = $self->connect;
    my $sth = $dbh->prepare("SELECT dist, distmtime FROM distmtimes");
    $sth->execute;
    my($dist,$distmtime);
    while (($dist,$distmtime) = $sth->fetchrow_array) {
        $self->{ALLlasttime}{$dist} = $distmtime;
    }
    $sth->finish;
}

sub checkfornew {
    my $self = shift;
    local $/ = "";
    my $dbh = $self->connect;
    my(@goners);
    my $time = time;
    my $alert;
    my @all;
    {
        my %seen;
        @all = sort grep { !$seen{$_}++ }
            keys %{$self->{ALLfound}},
                keys %{$self->{ALLlasttime}};
    }
    my $all = @all;
    $self->verbose(2, "Starting BIGLOOP over $all files\n");
    my $i = 0;
  BIGLOOP: for my $dist (@all) {
        #
        # Examine all files, even CHECKSUMS and READMEs
        #

        $i++;
        $self->verbose(2,".$dist.") unless $i%256;

        my $dio = PAUSE::dist->new(
                                   MAIN   => $self,
                                   DIST   => $dist,
                                   DBH    => $dbh,
                                   ALERT  => "",
                                   TIME   => $time,
                                   TARBIN => $self->{TARBIN},
                                   UNZIPBIN  => $self->{UNZIPBIN},
                                  );

        next BIGLOOP if $dio->ignoredist;

        if (exists $self->{ALLfound}{$dist}) {
            next BIGLOOP unless $dio->mtime_ok($self->{ALLlasttime}{$dist});
        } else {
            $dio->delete_goner;
            push @goners, $dist;
            next BIGLOOP;
        }
        $self->verbose(1,"\n    Examining $dist ...\n");
        sleep 1;   # I think this might help us against wild processes

        my $userid = PAUSE::dir2user($dist);
        $dio->{USERID} = $userid;

        $dio->examine_dist; # checks for perl, developer, version, etc. and untars
        my $skip = $dio->skip;
        next BIGLOOP if $skip;

        $dio->read_dist;
        $dio->extract_readme_and_yaml;
        $dio->check_blib;
        $dio->check_multiple_root;
        $dio->examine_pms;      # will switch user

        $dio->mail_summary;

        $alert .= $dio->alert;  # now $dio can go out of scope

    } continue {                # BIGLOOP
        my($dh) = DirHandle->new(".");
        for my $dirent ($dh->read) {
            next if $dirent eq "." || $dirent eq "..";
            rmtree $dirent;
        }
        $dh->close;
    }
        if ($alert) {
            print $alert;       # summary
            my($msg) = Mail::Send->new(
                                       To => $PAUSE::Config->{ADMIN},
                                       Subject => "Upload Permission or Version mismatch"
                                      );
            $msg->add("From", "PAUSE <$PAUSE::Config->{UPLOAD}>");
            my $fh  = $msg->open('sendmail');
            print $fh "Not indexed.\n\t$Id\n\n", $alert;
            $fh->close;
        }

}

sub rewrite02 {
    my $self = shift;
    #
    # Rewriting 02packages.details.txt
    #
    $self->verbose(2,"\n\nEntering rewrite02\n");

    my $dbh = $self->connect;
    my $repfile = "$MLROOT/../../modules/02packages.details.txt";
    my $list = "";
    my $olist = "";
    local($/) = "\n";
    if (
	-f "$repfile.gz" and
	open F, "$PAUSE::Config->{GZIP} --stdout --uncompress $repfile.gz|"
       ) {
	while (<F>) {
	    next if 1../^$/;
	    $olist .= $_;
	}
	close F;
    }
    my $date = HTTP::Date::time2str();
    my $sth = $dbh->prepare(qq{SELECT package, version, dist, file
                               FROM packages});
    $sth->execute;
    my(@row,@listing02);
    my $numrows = $sth->rows;
    $self->verbose(2,"numrows[$numrows]\n");
    while (@row = $sth->fetchrow_array) {
	my($one,$two);
	my $infile = $row[0];
	$infile =~ s/^.+:://;
	next unless $row[3];
	next unless index($row[3],"$infile.pm")>=0 or
            $row[3]=~/VERSION/i; # VERSION is Russ Allbery's idea to
                                 # force inclusion
	$row[1] =~ s/^\+//;
	$one=30;
        $two=8;
	if (length($row[0])>$one) {
	    $one += 8 - length($row[1]);
	    $two = length($row[1]);
	}
	push @listing02, sprintf "%-${one}s %${two}s  %s\n", @row;
    }
    my $numlines = @listing02;
    die "Absurd small number of lines" unless $numlines > 1000;
    my $header = qq{File:         02packages.details.txt
URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
Description:  Package names found in directory \$CPAN/authors/id/
Columns:      package name, version, path
Intended-For: Automated fetch routines, namespace documentation.
Written-By:   $Id
Line-Count:   $numlines
Last-Updated: $date\n\n};

    $list .= join "", sort {lc $a cmp lc $b} @listing02;
    if ($list ne $olist) {
	if (open F, "| $PAUSE::Config->{GZIP} --best > $repfile.gz") {
	    print F $header;
	    print F $list;
	} else {
	    $self->verbose(1,"Couldn't open 02packages...gz\n");
	    $self->alert("Couldn't open 02packages...gz");
	}
	close F or die "Couldn't close: $!";
    }
}

sub rewrite01 {
    my($self) = shift;
    #
    # Rewriting 01modules.index.html
    #
    $self->verbose(2, "\nEntering rewrite01\n");
    my $dbh = $self->connect;

    my $repfile = "$MLROOT/../../modules/01modules.index.html";
    my $list = "";
    my $olist = "";
    local $/;
    local *F;
    if (open F, $repfile) {
	while (<F>) {
	    $olist .= $_;
	}
	close F;
    } else {
	$self->verbose(1,"Couldn't open $repfile $!\n");
	$self->alert("Couldn't open $repfile $!");
    }
    my(%firstlevel,%achapter);
    my $sth = $dbh->prepare("SELECT modid, chapterid FROM mods");
    $sth->execute;
    while (my($modid,$chapterid) = $sth->fetchrow_array) {
	my($root,$colo) = $modid =~ /^([^:]+)(::)?/;
	$firstlevel{$root}++;
        # the determination of %achapter was introduced with rev 211.
        # Alternatives were tried in 212 and 214, but they had
        # uncountable misfits. 215 then was very similar to 211 but we
        # did sort above query by chapterid and got tons of misfits.
        # So we do not really have a solution. Every solution is
        # wrong, even the pre-211 solution. OK, I've taken out the
        # order by clause and retested, cheap_chapter deviates from
        # old chapter for Exception, Sort, and User, that's all.
        if ($colo) {
            if (! exists $achapter{$root}) {
                $achapter{"$root\::"} ||= $chapterid;
            }
        } else {
            delete $achapter{"$root\::"};
            $achapter{$root} ||= $chapterid;
        }
    }
    my(%c_fn,$chapterid,$shorttitle,@chaptitle);
    $sth = $dbh->prepare("SELECT chapterid, shorttitle FROM chapters");
    $sth->execute;
    @c_fn{@{$sth->{NAME}}} = 0..@{$sth->{NAME}}-1; # chapters
    while (($chapterid, $shorttitle) = $sth->fetchrow_array) {
	$chapterid =~ s/^\s+//;
	$chapterid =~ s/\D+.*//;
	$chaptitle[$chapterid] = $shorttitle;
    }

    $sth = $dbh->prepare("SELECT package, dist FROM packages");
    $sth->execute;
    my(@listing01,%count,$count);
    my(%seen);

    my(%usercache,%userdircache,$i);
    while (my($pkg,$pkgdist) = $sth->fetchrow_array) {
        my %pkg = (rootpack => $pkg, dist => $pkgdist);
        $pkg{rootpack} =~ s/:.*//;
        # We don't want to list perl distribution
        next if $pkg{dist} =~ m|/perl-?5|;
        if ($seen{$pkg{dist},$pkg{rootpack}}++) {
            next;
        }
        if ($firstlevel{$pkg{rootpack}}) {
            #print "01 will have: $pkg{rootpack}/$pkg{dist}\n";
        } else {
            next;
        }

        $i++;
        @pkg{qw/size mtime/} =
            (stat "$MLROOT/$pkg{dist}")[7,9];
        $count++ unless $count{$pkg{dist}}++;
        $pkg{size} =
            $pkg{size} > 700000 ?
                sprintf "%.1fM", $pkg{size}/1024/1024 :
                    $pkg{size} > 700 ?
                        sprintf "%dk", $pkg{size}/1024+0.5 :
                            "1k";
        # my(@parts) = split /\//, $pkg{dist};
        my $directory = File::Basename::dirname($pkg{dist});
        my $user = $usercache{$directory} ||= PAUSE::dir2user($pkg{dist});
        my $f = File::Basename::basename($pkg{dist});
        my $userdir = $userdircache{$user} ||= PAUSE::user2dir($user);
        die "no user for dist[$pkg{dist}]" unless $user;
        # die "no user in database with id[$user]" unless $User{$user};
        $pkg{userid} = $user;
        # $pkg{fullname} = $User{$user};
        $pkg{userdir} = $userdir;
        $pkg{useridfiller} = " "x(10-length($user));
        $pkg{filenameonly} = $f;
        $pkg{filenamefiller} =
            " "x(38-length($f)-length($pkg{size}));
        $pkg{mtimestr} =
            substr(HTTP::Date::time2str($pkg{mtime}),5,11);
        $pkg{young} =
            $pkg{mtime} > $^T - 60 * 60 * 24 * 14 ? "  +" : "";

        push @listing01, [@pkg{qw/rootpack  userdir      userid         useridfiller
                                dist     filenameonly filenamefiller size
                                mtimestr young        mtime/}];

        # now the symlinks.
        # we just wrote something like
        # Sybase      MEWP   sybperl-2.03.tar.gz     91.8  31 Jan 1996
        # we are in authors/id/
        $pkg{rootpack} =~ s/\*$//; # XXX seems stemming from already deleted code
        ($pkg{readme} = $pkg{dist}) =~
            s/(\.tar[._-]gz|\.tar.Z|\.tgz|\.zip)$/.readme/;
        $pkg{readmefn} = File::Basename::basename($pkg{readme});

        if (0) {   # old method before cheap_chapterid, it is buggy in
                   # that it has only one chapter per root namespace
            my $sth2 = $dbh->prepare(qq{SELECT chapterid
                                  FROM mods
                                  WHERE modid=?});
            $sth2->execute($pkg{rootpack});
            if ($sth2->rows == 1) {
                ($pkg{chapterid}) = $sth2->fetchrow_array;
            } else {
                my $sth3 = $dbh->prepare(qq{SELECT chapterid
                                 FROM mods
                                 WHERE modid
                                  LIKE ?});
                $sth3->execute("$pkg{rootpack}::%");
                ($pkg{chapterid}) = $sth3->fetchrow_array;
            }
        }

        my $cheap_chapterid;
        if (1) { # new method rev 216, same bug: only one chap-per-nmspace
            $cheap_chapterid = $achapter{$pkg{rootpack}}
                || $achapter{"$pkg{rootpack}\::"};
        }

        if (0) { # compares the old and the new, so both above must be on
            unless ($pkg{chapterid} eq $cheap_chapterid) {
                $self->verbose(1,
                               "WARNING: rootpack[$pkg{rootpack}] ".
                               "old chapterid[$pkg{chapterid}] cheap ".
                               "chapterid[$cheap_chapterid]\n");
            }
        }

        if (1) {                # finally assign the new solution
            $pkg{chapterid} = $cheap_chapterid;
        }

        if (defined $pkg{chapterid}) {
            if (defined $chaptitle[$pkg{chapterid}]) {
                $pkg{chapter} = $chaptitle[$pkg{chapterid}]
            } else {
                $pkg{chapter} = "99_Not_In_Modulelist";
                $self->verbose(1,"\nfound no chapterid for $pkg{rootpack}\n");
            }
        } else {
            $pkg{chapter} = "99_Not_In_Modulelist";
            $self->verbose(1,"found no chapter for $pkg{rootpack}\n");
        }


        $self->verbose(2,".") if !($i % 16);
        my $bymod = "$MLROOT/../../modules/".
            "by-module/$pkg{rootpack}/$pkg{filenameonly}";
        my $bycat = "$MLROOT/../../modules/".
            "by-category/$pkg{chapter}/$pkg{rootpack}/$pkg{filenameonly}";
        next if -e $bymod and -e $bycat;

        $self->chdir_ln_chdir($MLROOT,
                              "../../../authors/id/$pkg{dist}",
                              "../../modules/by-module/$pkg{rootpack}".
                              "/$pkg{filenameonly}");
        $self->chdir_ln_chdir($MLROOT,
                              "../../../authors/id/$pkg{readme}",
                              "../../modules/by-module/$pkg{rootpack}".
                              "/$pkg{readmefn}")
            if -f $pkg{readme};
        $self->chdir_ln_chdir($MLROOT,
                              "../../../authors/id/$userdir",
                              "../../modules/by-module/$pkg{rootpack}/$pkg{userid}");
        $self->chdir_ln_chdir($MLROOT,
                              "../../../../authors/id/$pkg{dist}",
                              "../../modules/by-category/$pkg{chapter}".
                              "/$pkg{rootpack}/$pkg{filenameonly}");
        $self->chdir_ln_chdir($MLROOT,
                              "../../../../authors/id/$pkg{readme}",
                              "../../modules/by-category/$pkg{chapter}".
                              "/$pkg{rootpack}/$pkg{readmefn}")
            if -f $pkg{readme};
        $self->chdir_ln_chdir($MLROOT,
                              "../../../../authors/id/$userdir",
                              "../../modules/by-category/$pkg{chapter}".
                              "/$pkg{rootpack}/$pkg{userid}");
    }
    $list = qq{
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>Modules on CPAN alphabetically</title></head><body>
<h1>CPAN\'s $count modules distributions</h1>
<h3>in alphabetical order by modules contained in the distributions</h3>
<i>} .
    scalar gmtime() .
	qq{ GMT</i>

<p>The list contains modules distribution files on CPAN for modules that
are <b>not</b> included in the perl standard distribution but
<b>are</b> included in the current release of <a
href="00modlist.long.html">Perl Module List</a>. To keep the size of
this list acceptable, it does not list which modules are in each
package. To get at those, it is recommended to use the CPAN.pm module
or read the detailed <a
href="02packages.details.txt.gz">listing</a>.</p>

<p>Column <b><code>module/category</code></b> contains the module or
category name, column <b><code>author/maintainer</code></b> the userid
of the author or maintainer which is a hyperlink to her homedirectory.
The filename in column <b><code>current distribution file</code></b>
is a link to the real file. The last column <b><code>young</code></b>
contains a plus sign if the file is younger than two weeks.</p>

<p><i>See also:</i></p>

<ul>

<li> <a href="01modules.mtime.html">Most recent uploads</a> sorted by uploadtime.</li>

<li> <a href="../CPAN.html">CPAN\'s <b>front page</b></a> by Jon Orwant.</li>

<li> <a href="00modlist.long.html">The <b>Module List</b></a>
by Tim Bunce and Andreas K&ouml;nig</li>

<li> <a href="../authors/00whois.html"><b>Who is who</b></a></li>

<li> The detailed <a href="02packages.details.txt.gz">listing</a> of all
packages found in these distribution files</li>

</ul>
<hr />
<pre>
module/     author/   current distribution file       size   uploaded   young
category    maintainer

};

    $list .= join("",
		  map {sprintf(
			       qq{%-12s<a href="../authors/id/%s">%s</a>%s<a
 href="../authors/id/%s">%s</a> %s %s  %s%s\n},
			       @$_
			      )}
		  sort {lc $a->[0] cmp lc $b->[0] # package(root)
			    or
				$a->[2] cmp $b->[2] # userid
				    or
					lc $a->[5] cmp lc $b->[5] # filename
                                    } @listing01
		 );
    $list .= q{</pre></body></html>};

    my($comparelist) = $list;
    $comparelist =~ s/.+?<hr\b//s; # delete the intro (date!) 
        $olist       =~ s/.+?<hr\b//s;

    if ($comparelist ne $olist) {
	if (open F, ">$repfile") {
	    print F $list;
	    close F;
	    $self->write_01sorted(\@listing01);
	} else {
	    $self->verbose(1,"Couldn't open 01modules...\n");
	    $self->alert("Couldn't open 01modules...");
	}
    }
}

sub write_01sorted {
    my($self, $listing) = @_;
    my($n) = 150;
    my $list = qq{\n<HEAD><TITLE>Modules on CPAN sorted by upload date</TITLE></HEAD><BODY>\n<H1>CPAN\'s $n most recent uploads</H1>\n<H3>ordered by timestamp of the distributions</H3>\n\nA description of the list can be found in <A HREF="01modules.index.html">01modules.index.html</A>.\n<HR>\n<PRE>\nauthor/   distribution file                     size   uploaded\nmaintainer\n\n};

    my(%seen);
    for my $l (
               sort {$b->[10] <=> lc $a->[10] # mtime
		 } @$listing
              ) {
        next if $seen{$l->[4]}++; # dist
        my %package;
        @package{qw{package userdir userid useridfiller dist filenameonly
                    filenamefiller size mtimestr young mtime}} = @$l;
        $package{filenamefiller} =
	    " "x(40-length($package{filenameonly})-length($package{size}));
        $list .= sprintf(
                         qq{<A HREF="../authors/id/%s">%s</A>%s<A
 HREF="../authors/id/%s">%s</A> %s %s   %s\n},
                         @package{qw{userdir userid useridfiller dist filenameonly
                                     filenamefiller size mtimestr}}
                        );
        last unless --$n;
    }
    $list .= q{</PRE></BODY>};
    my $repfile = "$MLROOT/../../modules/01modules.mtime.html";
    # $self->verbose(1,"Writing $repfile\n");
    if (open F, ">$repfile") {
        print F $list;
        close F;
    } else {
        die "Could not open >$repfile:$!";
    }
}

sub rewrite03 {
    my($self) = shift;
    #
    # Rewriting 03modlist.data
    #
    $self->verbose(2,"\nEntering rewrite03\n");

    my $repfile = "$MLROOT/../../modules/03modlist.data";
    my $list = "";
    my $olist = "";
    local($/) = "\n";
    if (
        -f "$repfile.gz" and
        open F, "$PAUSE::Config->{GZIP} --stdout --uncompress $repfile.gz|"
       ) {
        if ($] > 5.007) {
            require Encode;
            binmode F, ":utf8";
        }
        while (<F>) {
            next if 1../^\s*$/;
            $olist .= $_;
        }
        close F;
    } else {
        $self->verbose(1,"Couldn't open $repfile $!\n");
        $self->alert("Couldn't open $repfile $!");
    }
    my $date = HTTP::Date::time2str();
    my $dbh = $self->connect;
    my $sth = $dbh->prepare(qq{SELECT modid, statd, stats, statl,
                                    stati, statp, description, userid, chapterid
                             FROM mods WHERE mlstatus = "list"});
    $sth->execute;
    my $header = sprintf qq{File:        03modlist.data
Description: These are the data that are published in the module
	list, but they may be more recent than the latest posted
	modulelist. Over time we\'ll make sure that these data
	can be used to print the whole part two of the
	modulelist. Currently this is not the case.
Modcount:    %d
Written-By:  %s
Date:        %s

}, $sth->rows, $Id, $date;

    $list = qq{
    package CPAN::Modulelist;
    # Usage: print Data::Dumper->new([CPAN::Modulelist->data])->Dump or similar
    # cannot 'use strict', because we normally run under Safe
    # use strict;

    sub data {
      my \$result = {};
      my \$primary = "modid";
      for (\@\$CPAN::Modulelist::data){
	my %hash;
	\@hash{\@\$CPAN::Modulelist::cols} = \@\$_;
	\$result->{\$hash{\$primary}} = \\%hash;
      }
      \$result;

    }
  };


    $list .= Data::Dumper->new([
                                $sth->{NAME},
                                $self->as_ds($sth)
                               ],
                               ["CPAN::Modulelist::cols",
                                "CPAN::Modulelist::data"]
                              )->Dump;

    $list =~ s/^\s+//gm;

    if ($list ne $olist) {
        if (open F, "| $PAUSE::Config->{GZIP} --best > $repfile.gz") {
            if ($] > 5.007) {
                require Encode;
                binmode F, ":utf8";
            }
            print F $header;
            print F $list;
        } else {
            die "Couldn't open | gzip...$repfile.gz";
        }
        close F or die "Couldn't close: $!";
    }
}

sub chdir_ln_chdir {
    my($self,$postdir,$from,$to) = @_;
    chdir $postdir or die "Couln't chdir to $postdir";
    my($dir) = File::Basename::dirname($to);
    mkpath $dir;
    chdir $dir or die "Couldn't chdir to $dir $!";
    my $pwd = Cwd::cwd();
    unless (-e $from){
        require Carp;
        Carp::confess("not exists: $from from $dir");
        # return;
    }
    if (-l $from) {
        $self->verbose(1,"Won't create symlink[$to] to symlink[$from] in pwd[$pwd]\n");
        return;
    }
    $to = File::Basename::basename($to);
    if (-l $to) {
	my($foundlink) = readlink $to or die "Couldn't read link $to in $dir";
	if ($foundlink eq $from) {
            # $self->verbose(2,"Keeping old symlink $from in dir $dir file $to\n");
	    return;
	}
    }
    if (-l $to) {
	$self->verbose(1, qq{unlinking symlink $to in $dir\n});
	unlink $to or die qq{Couldn\'t unlink $to $!};
    } elsif (-f $to) {
	$self->verbose(1, "unlinking file $to in dir $dir\n");
	unlink $to or die qq{Couldn\'t unlink $to $!};
    } elsif (-d $to) {
	$self->verbose(1,"ALERT: Have to rmtree $to in dir $dir\n");
	rmtree $to;
    }
    symlink $from, $to or die "Couldn't symlink $from, $to $!";
    chdir $postdir or die "Couldn't chdir to $postdir $!"
}

sub as_ds {
    my($self,$sth) = @_;
    my $result;
    # If we produce the datastructure as it would seem natural,
    # i.e. each primary key became key in a hash, and each table row
    # would be represented as a hash, we would produce 250k instead of
    # 60. After compression the ratio is still 2:1.
    $result = [];
    while (my @row = $sth->fetchrow_array) {
        if ($] > 5.007) {
            require Encode;
            for (@row) {
                defined && /[^\000-\177]/ && Encode::_utf8_on($_);
            }
        }
        push @$result, \@row;
    }
    $result;
}


#####################################################################
######################### start of packages #########################
#####################################################################


{
    package PAUSE::dist;
    use vars qw(%CHECKSUMDONE $AUTOLOAD);

    sub DESTROY {}

    # package PAUSE::dist;
    sub new {
        my($me) = shift;
        bless { @_ }, ref($me) || $me;
    }

    # package PAUSE::dist;
    sub ignoredist {
        my $self = shift;
        my $dist = $self->{DIST};
        if ($dist =~ m|/\.|) {
            $self->verbose(1,"Warning: dist[$dist] has illegal filename\n");
            return 1;
        }
        return 1 if $dist =~ /(\.readme|\.sig|CHECKSUMS)$/;
        # Stupid to have code that needs to be maintained in two places,
        # here and in edit.pm:
        return 1 if $dist =~ m!CNANDOR/(?:mp_(?:app|debug|doc|lib|source|tool)|VISEICat(?:\.idx)?|VISEData)!;
        return;
    }

    # package PAUSE::dist;
    sub delete_goner {
        my $self = shift;
        my $dist = $self->{DIST};
        my $dbh = $self->connect;
        $dbh->do("DELETE FROM packages WHERE dist='$dist'");
        $dbh->do("DELETE FROM distmtimes WHERE dist='$dist'");
    }

    # package PAUSE::dist;
    sub writechecksum {
        my($self, $dir) = @_;
        return if $CHECKSUMDONE{$dir}++;
        local($CPAN::Checksums::CAUTION) = 1;
        local($CPAN::Checksums::SIGNING_PROGRAM) =
            $PAUSE::Config->{CHECKSUMS_SIGNING_PROGRAM};
        local($CPAN::Checksums::SIGNING_KEY) =
            $PAUSE::Config->{CHECKSUMS_SIGNING_KEY};
        CPAN::Checksums::updatedir($dir);
    }

    # package PAUSE::dist;
    sub mtime_ok {
        my $self = shift;
        my $otherts = shift || 0;
        my $dist = $self->{DIST};
        my $dbh = $self->connect;
        unless ($otherts){ # positive $otherts means it was alive last time
            $dbh->do("DELETE FROM distmtimes WHERE dist='$dist'");
            $dbh->do("INSERT INTO distmtimes (dist) VALUES ('$dist')");
        }
        my $mtime = (stat "$MLROOT/$dist")[9];
        my $dirname = File::Basename::dirname("$MLROOT/$dist");
        my $checksumtime = (stat "$dirname/CHECKSUMS")[9] || 0;

        if ($mtime > $checksumtime - 86400) {
            $self->writechecksum($dirname);
        }
        if ($mtime > $otherts) {
            $dbh->do(qq{UPDATE distmtimes
                     SET distmtime='$mtime', distmdatetime=from_unixtime('$mtime')
                   WHERE dist='$dist'});
            $self->verbose(1,"DEBUG5: mtime assigned [$mtime] to dist[$dist]\n");
            return 1;
        }
        return;
    }

    # package PAUSE::dist;
    sub alert {
        my $self = shift;
        my $what = shift;
        if (defined $what) {
            $self->{ALERT} ||= "";
            $self->{ALERT} .= " $what";
        } else {
            return $self->{ALERT};
        }
    }

    # package PAUSE::dist;
    sub untar {
        my $self = shift;
        my $dist = $self->{DIST};
        local *TARTEST;
        my $tarbin = $self->{TARBIN};
        open TARTEST, "$tarbin tzf $MLROOT/$dist |";
        while (<TARTEST>) {
            if (m:^\.\./: || m:/\.\./: ) {
                $self->verbose(1,"\n\n    ALERT: Updir detected in $dist!\n\n");
                $self->alert("ALERT: Updir detected in $dist!");
                $self->{COULD_NOT_UNTAR}++;
                return;
            }
        }
        unless (close TARTEST) {
            $self->verbose(1,"\nCould not untar $dist!\n");
            $self->alert("\nCould not untar $dist!\n");
            $self->{COULD_NOT_UNTAR}++;
            return;
        }
        $self->verbose(1,"Going to untar $MLROOT/$dist\n");
        unless (system($tarbin,'xzf',"$MLROOT/$dist")==0) {
            print "Some error occurred during unzippping. Let's retry:\n";
            system("$tarbin xvzf $MLROOT/$dist")==0 or return;
        }
        return 1;
    }

    sub skip { shift->{SKIP} }

    # package PAUSE::dist;
    sub examine_dist {
        my($self) = @_;
        my $dist = $self->{DIST};
        my($suffix,$skip);
        $suffix = $skip = "";
        if ($dist =~ /$PAUSE::mldistwatch::ISAPERL/ox) {
            my($u) = PAUSE::dir2user($dist); # =~ /([A-Z][^\/]+)/; # XXX dist2user
            $self->verbose(1,"perl dist $dist from $u. Is he a trusted guy?\n");
            use DBI;
            my $adbh = DBI->connect(
                                    $PAUSE::Config->{AUTHEN_DATA_SOURCE_NAME},
                                    $PAUSE::Config->{AUTHEN_DATA_SOURCE_USER},
                                    $PAUSE::Config->{AUTHEN_DATA_SOURCE_PW},
                                   ) or die $DBI::errstr;
            my $query = "SELECT * FROM grouptable
                   WHERE user= ?
                     AND ugroup='pumpking'";
            my $sth = $adbh->prepare($query);
            $sth->execute($u);
            if ($sth->rows > 0){
                $skip = 0;
                $self->verbose(1,"Yes.\n");
            } else {
                $skip = 1;
                $self->verbose(1,"NO! Skip set to [$skip]\n");
            }
            $sth->finish;
            $adbh->disconnect;
            if ($dist =~ /\.(tgz|tar[\._-]gz|tar\.Z)$/) {
                $suffix = $1;
            } else {
                $self->verbose(1,"A perl distro ($dist) with an unusual suffix!\n");
                $self->alert("A perl distro ($dist) with an unusual suffix!");
            }
            unless ($skip) {
                $skip = 1 unless $self->untar;
            }
        } else {                # ! isa_perl
            if (
                $dist =~ /\d\.\d+_\d/
                ||
                $dist =~ /TRIAL/
               ) {
                $self->verbose(1,"  developer release\n");
                $self->{SUFFIX} = "N/A";
                $self->{SKIP}   = 1;
                return;
            }
            if ($dist =~ /\.(tgz|tar[\._-]gz|tar\.Z)$/) {
                $suffix = $1;
                $skip = 1 unless $self->untar;
            } elsif ($dist =~ /\.pm\.(Z|gz)$/) {
                # By not setting suffix we prohibit extracting README
                my $file = File::Basename::basename($dist);
                File::Copy::copy "$MLROOT/$dist", $file;
                my $willunzip = $file;
                $willunzip =~ s/\.(Z|gz)$//;
                unless (PAUSE::gunzip($file,$willunzip)) {
                    $self->verbose(1,"    no gunzip on $file\n");
                }
            } elsif ($dist =~ /\.zip$/) {
                $suffix = "zip";
                my $unzipbin = $self->{UNZIPBIN};
                my $system = "$unzipbin $MLROOT/$dist > /dev/null 2>&1";
                unless (system($system)==0) {
                    $self->verbose(1,
                                   "Some error occurred during unzippping. ".
                                   "Let's read unzip -t:\n");
                    system("$unzipbin -t $MLROOT/$dist");
                }
            } else {
                $self->verbose(1,"  no dist\n");
                $skip = 1;
            }
        }
        $self->{SUFFIX} = $suffix;
        $self->{SKIP}   = $skip;
    }

    sub connect {
        my($self) = @_;
        my $main = $self->{MAIN};
        $main->connect;
    }

    sub disconnect {
        my($self) = @_;
        my $main = $self->{MAIN};
        $main->disconnect;
    }

    # package PAUSE::dist;
    sub mail_summary {
        my($self) = @_;
        my $distro = $self->{DIST};
        my $author = PAUSE::dir2user($distro);
        my @m;

        push @m, "The following report has been written by the PAUSE namespace indexer.
Please contact modules\@perl.org if there are any open questions.
  $PAUSE::mldistwatch::Id\n";
        my $time = gmtime;
        my $mtime = gmtime((stat "$MLROOT/$distro")[9]);
        my $nfiles = scalar @{$self->{MANIFOUND}};
        my $pmfiles = grep /\.pm$/, @{$self->{MANIFOUND}};
        my $dbh = $self->connect;
        my $sth = $dbh->prepare("SELECT asciiname, fullname
                                 FROM   users
                                 WHERE userid=?");
        $sth->execute($author);
        my($u) = $sth->fetchrow_hashref;
        my $asciiname = $u->{asciiname} || $u->{fullname} || "name unknown";
        my $substrdistro = substr $distro, 5;
        my($distrobasename) = $substrdistro =~ m|.*/(.*)|;
        my $show_meta_yml = 1;
        if ($show_meta_yml) {
            push @m, qq{
               User: $author ($asciiname)
  Distribution file: $distrobasename
    Number of files: $nfiles
         *.pm files: $pmfiles
             README: $self->{README}
           META.yml: $self->{YAML}
  Timestamp of file: $mtime UTC
   Time of this run: $time UTC\n\n};
        } else {
            push @m, qq{
               User: $author ($asciiname)
  Distribution file: $distrobasename
    Number of files: $nfiles
         *.pm files: $pmfiles
             README: $self->{README}
  Timestamp of file: $mtime UTC
   Time of this run: $time UTC\n\n};
        }
        my $tf = Text::Format->new(firstIndent=>0);

        if (0) {
        } elsif ($self->{HAS_MULTIPLE_ROOT}) {

            push @m, $tf->format(qq{The distribution does not unpack
                into a single directory and is therefore not being
                indexed. Hint: try 'make dist'.});

            push @m, qq{\n\n};

        } elsif ($self->{HAS_BLIB}) {

            push @m, $tf->format(qq{The distribution contains a blib/
                directory and is therefore not being indexed. Hint:
                try 'make dist'.});

            push @m, qq{\n\n};

        } else {
            my $st = $self->{INDEX_STATUS};
            if ($st && ref $st && %$st) {
                push @m, qq{The following packages (grouped by status) have been found in the distro:\n\n};
                my $Lstatus = 0;

                for my $p (sort {
                    $st->{$b}{status} <=> $st->{$a}{status}
                        or
                            $a cmp $b
                        } keys %$st) {
                    my $status = $st->{$p}{status};
                    if ($status != $Lstatus) {
                        my $heading =
                            PAUSE::mldistwatch::Constants::heading($status) ||
                                  "UNKNOWN (status=$status)";
                        push @m, sprintf "Status: %s
%s\n\n", $heading, "="x(length($heading)+8);
                    }
                    my $tf13 = Text::Format->new(
                                                 bodyIndent => 13,
                                                 firstIndent => 13,
                                                );
                    my $verb_status = $tf13->format($st->{$p}{verb_status});
                    $verb_status =~ s/^\s+//; # otherwise this line is too long
                    push @m, sprintf("     module: %s
    version: %s
    in file: %s
     status: %s\n",
                                     $p,
                                     $st->{$p}{version},
                                     $st->{$p}{infile},
                                     $verb_status,
                                    );
                    $Lstatus = $status;
                }
            } else {
                if ($pmfiles > 0) {
                    push @m, qq{No package statements could be found in the }.
                        qq{distro (maybe a script\nor documentation distribution?)\n\n};
                } else {
                    # no need to write a report at all
                    return;
                }

            }
        }
        push @m, qq{__END__\n};
        my $pma = PAUSE::MailAddress->new_from_userid($author,{dbh => $self->connect});
        my $to = $pma->address;
        my($msg) = Mail::Send->new(
                                   To => join(", ",
                                              $to,
                                              $PAUSE::Config->{ADMIN}, # no sec breach
                                             ),
                                   Subject => "PAUSE indexer report $substrdistro",
                                  );
        $msg->add("From", "PAUSE <$PAUSE::Config->{UPLOAD}>");
        my $fh  = $msg->open('sendmail');
        print $fh @m;
        $fh->close;
        $self->verbose(1,"-->> Sent mail about $substrdistro\n");
    }

    # package PAUSE::dist;
    sub index_status {
        my($self,$pack,$version,$infile,$status,$verb_status) = @_;
        $self->{INDEX_STATUS}{$pack} = {
                                        version => $version,
                                        infile => $infile,
                                        status => $status,
                                        verb_status => $verb_status,
                                       };
    }

    # package PAUSE::dist;
    sub check_blib {
        my($self) = @_;
        if (grep m|^[^/]+/blib/|, @{$self->{MANIFOUND}}) {
            $self->{HAS_BLIB}++;
            return;
        }
        # sometimes they package their stuff deep inside a hierarchy
        my @found = @{$self->{MANIFOUND}};
        my $endless = 0;
      DIRDOWN: while () {
            # step down directories as long as possible
            my %seen;
            my @top = grep { s|/.*||; !$seen{$_}++ } map { $_ } @found;
            if (@top == 1) {
                # print $top[0];
                my $success = 0;
                for (@found){ # note, we modify found, not top!
                    s|\Q$top[0]\E/|| && $success++;
                }
                last DIRDOWN unless $success; # no directory to step down anymore
                if (++$endless > 10) {
                    $self->alert("ENDLESS LOOP detected in $self->{DIST}!");
                    last DIRDOWN;
                }
                next DIRDOWN;
            }
            # more than one entry in this directory means final check
            if (grep m|^blib/|, @found) {
                $self->{HAS_BLIB}++;
            }
            last DIRDOWN;
        }
    }

    # package PAUSE::dist;
    sub check_multiple_root {
        my($self) = @_;
        my %seen;
        my @top = grep { s|/.*||; !$seen{$_}++ } map { $_ } @{$self->{MANIFOUND}};
        if (@top > 1) {
            $self->{HAS_MULTIPLE_ROOT}++;
        }
    }

    # package PAUSE::dist;
    sub filter_pms {
        my($self) = @_;
        my @pmfile;

        # very similar code is in PAUSE::package::filter_ppps
      MANI: for my $mf ( @{$self->{MANIFOUND}} ) {
            next unless $mf =~ /\.pm$/i;
            my($inmf) = $mf =~ m!^[^/]+/(.+)!; # go one directory down
            next if $inmf =~ m!^(?:t|inc)/!;
            if ($self->{YAML_CONTENT}){
                my $no_index = $self->{YAML_CONTENT}{no_index}
                               || $self->{YAML_CONTENT}{private}; # backward compat
                if (ref($no_index) eq 'HASH') {
                    my %map = (
                               file => qr{\z},
                               directory => qr{/},
                              );
                    for my $k (qw(file directory)) {
                        next unless my $v = $no_index->{$k};
                        my $rest = $map{$k};
                        if (ref $v eq "ARRAY") {
                            for my $ve (@$v) {
                                $ve =~ s|/+$||;
                                if ($inmf =~ /^$ve$rest/){
                                    $self->verbose(1,"skipping inmf[$inmf] due to ve[$ve]");
                                    next MANI;
                                } else {
                                    $self->verbose(1,"NOT skipping inmf[$inmf] due to ve[$ve]");
                                }
                            }
                        } else {
                            $v =~ s|/+$||;
                            if ($inmf =~ /^$v$rest/){
                                $self->verbose(1,"skipping inmf[$inmf] due to v[$v]");
                                next MANI;
                            } else {
                                $self->verbose(1,"NOT skipping inmf[$inmf] due to v[$v]");
                            }
                        }
                    }
                } else {
                    $self->verbose(1,"no keyword 'no_index' or 'private' in YAML_CONTENT");
                }
            } else {
                # $self->verbose(1,"no YAML_CONTENT"); # too noisy
            }
            push @pmfile, $mf;
        }
        $self->verbose(1,"pmfile[@pmfile]");
        @pmfile;
    }

    # package PAUSE::dist;
    sub examine_pms {
        my $self = shift;
        return if $self->{HAS_BLIB};
        return if $self->{HAS_MULTIPLE_ROOT};
        return if $self->{COULD_NOT_UNTAR}; # XXX not yet reached, we
                                            # need to re-examine what
                                            # happens without SKIP.
                                            # Currently SKIP shadows
                                            # the event of
                                            # could_not_untar
        my $dist = $self->{DIST};

        my $binary_dist;
        $binary_dist = 1 if $dist =~ /-bin-/i;

        my @pmfile = $self->filter_pms;
        for my $pmfile (@pmfile) {
            if ($binary_dist) {
                next unless $pmfile =~ /\b(Binary|Port)\b/; # XXX filename good,
                # package would be
                # better
            } elsif ($pmfile =~ m|/blib/|) {
                $self->alert("Still a blib directory detected:
  dist[$dist]pmfile[$pmfile]
");
                next;
            }

            $self->chown_unsafe;

            my $fio = PAUSE::pmfile->new(
                                         DIO => $self,
                                         PMFILE => $pmfile,
                                         TIME => $self->{TIME},
                                         USERID => $self->{USERID},
                                         YAML_CONTENT => $self->{YAML_CONTENT},
                                        );
            $fio->examine_fio;
        }
    }

    sub chown_unsafe {
        my($self) = @_;
        return if $self->{CHOWN_UNSAFE_DONE};
        use File::Find;
        my(undef,undef,$uid,$gid) = getpwnam("UNSAFE");
        find(sub {
                 chown $uid, $gid, $_;
             },
             "."
            );
        $self->{CHOWN_UNSAFE_DONE}++;
    }

    # package PAUSE::dist;
    sub read_dist {
        my $self = shift;
        my(@manifind) = sort keys %{ExtUtils::Manifest::manifind()};
        my $manifound = @manifind;
        $self->{MANIFOUND} = \@manifind;
        my $dist = $self->{DIST};
        unless (@manifind){
            $self->verbose(1,"NO FILES! in dist $dist?");
            return;
        }
        $self->verbose(1,"Found $manifound files in dist $dist, first $manifind[0]\n");
    }

    # package PAUSE::dist;
    sub extract_readme_and_yaml {
        my $self = shift;
        my($suffix) = $self->{SUFFIX};
        return unless $suffix;
        my $dist = $self->{DIST};
        my @manifind = @{$self->{MANIFOUND}};
        my(@readme) = grep /(^|\/)readme/i, @manifind;
        my($sans) = $dist =~ /(.*)\.\Q$suffix\E$/;
        if (@readme) {
            my $readme;
            if ($sans =~ /-bin-?(.*)/) {
                my $vers_arch = quotemeta $1;
                my @grep;
                while ($vers_arch) {
                    if (@grep = grep /$vers_arch/, @readme) {
                        @readme = @grep;
                        last;
                    }
                    $vers_arch =~ s/^[^\-]+-?//;
                }
            }
            $readme = $readme[0];
            for (1..$#readme) {
                $readme = $readme[$_] if length($readme[$_]) < length($readme);
            }
            $self->{README} = $readme;
            File::Copy::copy $readme, "$MLROOT/$sans.readme";
            utime((stat $readme)[8,9], "$MLROOT/$sans.readme");
        } else {
            $self->{README} = "No README found";
            $self->verbose(1,"No readme in $dist\n");
        }
        my(@yaml) = grep !m|/t/|, grep m|/META\.yml$|, @manifind;
        if (@yaml) {
            if (@yaml == 1) {
                my $yaml = $yaml[0];
                $self->{YAML} = $yaml;
                File::Copy::copy $yaml, "$MLROOT/$sans.meta";
                utime((stat $yaml)[8,9], "$MLROOT/$sans.meta");
                eval { $self->{YAML_CONTENT} = YAML::LoadFile($yaml); };
                if ($@) {
                    if ($@ =~ /msg: Unrecognized implicit value/) {
                        # let's retry, but let's not expect that this
                        # will work. MakeMaker 6.16 had a bug that
                        # could be fixed like this, at least for
                        # Pod::Simple

                        my $cat = do { open my($f), $yaml or die; local $/; <$f> };
                        $cat =~ s/:(\s+)(\S+)$/:$1"$2"/mg;
                        eval { $self->{YAML_CONTENT} = YAML::Load $cat; };
                        if ($@) {
                            $self->{YAML_CONTENT} = {};
                            $self->{YAML} = "META.yml found but error encountered while loading: $@";
                        }

                    } else {
                        $self->{YAML_CONTENT} = {};
                        $self->{YAML} = "META.yml found but error encountered while loading: $@";
                    }
                }
            } else {
                # Reminder: perl itself comes with a couple of META.yml
                $self->{YAML} = sprintf "%d META.yml found, ignoring\n", scalar @yaml;
            }
        } else {
            $self->{YAML} = "No META.yml found\n";
            $self->verbose(1,"No META.yml in $dist");
        }
    }

    sub verbose {
        my($self,$level,@what) = @_;
        my $main = $self->{MAIN};
        $main->verbose($level,@what);
    }

}

{
    package PAUSE::mldistwatch::Constants;
    # constants used for index_status:
    use constant EDUALOLDER => 50; # pumpkings only
    use constant EDUALYOUNGER => 30; # pumpkings only
    use constant EMISSPERM => 20;
    use constant EOLDRELEASE => 4;
    use constant EMTIMEFALLING => 3;
    use constant EVERFALLING => 2;
    use constant OK => 1;
    our $heading =
        {
         EMISSPERM() => "Permission missing",
         EDUALOLDER() => "An older dual-life module stays reference",
         EDUALYOUNGER() => "Dual-life module stays reference",
         EVERFALLING() => "Falling version number",
         EMTIMEFALLING() => "Falling mtime on a file (category to be deprecated)",
         EOLDRELEASE() => "Release seems outdated",
         OK() => "Successfully indexed",
        };

    sub heading {
        $heading->{shift};
    }
}

{
    package PAUSE::pmfile;
    use vars qw($AUTOLOAD);

    sub DESTROY {}

    sub verbose {
        my($self,$level,@what) = @_;
        my $main = $self->{DIO};
        $main->verbose($level,@what);
    }

    # package PAUSE::pmfile;
    sub new {
        my($me) = shift;
        bless { @_ }, ref($me) || $me;
    }

    # package PAUSE::pmfile;
    sub simile {
        my($self,$file,$package) = @_;
        # MakeMaker gives them the chance to have the file Simple.pm in
        # this directory but have the package HTML::Simple in it.
        # Afaik, they wouldn't be able to do so with deeper nested packages
        $file =~ s|.*/||;
        $file =~ s|\.pm||;
        my $ret = $package =~ m/\b\Q$file\E$/;
        $ret ||= 0;
        $self->verbose(1,"simile: file[$file] package[$package] ret[$ret]\n");
        $ret;
    }

    # package PAUSE::pmfile;
    sub alert {
        my $self = shift;
        my $what = shift;
        my $dio = $self->{DIO};
        $dio->alert($what);
    }

    sub connect {
        my($self) = @_;
        my $dio = $self->{DIO};
        $dio->connect;
    }

    sub disconnect {
        my($self) = @_;
        my $dio = $self->{DIO};
        $dio->disconnect;
    }

    # package PAUSE::pmfile;
    sub filter_ppps {
        my($self,@ppps) = @_;
        my @res;

        # very similar code is in PAUSE::dist::filter_pms
      MANI: for my $ppp ( @ppps ) {
            if ($self->{YAML_CONTENT}){
                my $no_index = $self->{YAML_CONTENT}{no_index}
                               || $self->{YAML_CONTENT}{private}; # backward compat
                if (ref($no_index) eq 'HASH') {
                    my %map = (
                               package => qr{\z},
                               namespace => qr{::},
                              );
                    for my $k (qw(package namespace)) {
                        next unless my $v = $no_index->{$k};
                        my $rest = $map{$k};
                        if (ref $v eq "ARRAY") {
                            for my $ve (@$v) {
                                $ve =~ s|::$||;
                                if ($ppp =~ /^$ve$rest/){
                                    $self->verbose(1,"skipping ppp[$ppp] due to ve[$ve]");
                                    next MANI;
                                } else {
                                    $self->verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]");
                                }
                            }
                        } else {
                            $v =~ s|::$||;
                            if ($ppp =~ /^$v$rest/){
                                $self->verbose(1,"skipping ppp[$ppp] due to v[$v]");
                                next MANI;
                            } else {
                                $self->verbose(1,"NOT skipping ppp[$ppp] due to v[$v]");
                            }
                        }
                    }
                } else {
                    $self->verbose(1,"no keyword 'no_index' or 'private' in YAML_CONTENT");
                }
            } else {
                # $self->verbose(1,"no YAML_CONTENT"); # too noisy
            }
            push @res, $ppp;
        }
        $self->verbose(1,"res[@res]");
        @res;
    }

    # package PAUSE::pmfile;
    sub examine_fio {
        # fio: file object
        my $self = shift;
        my $dist = $self->{DIO}{DIST};
        my $dbh = $self->connect;
        my $pmfile = $self->{PMFILE};


        my($filemtime) = (stat $pmfile)[9];
        $self->{MTIME} = $filemtime;

        my($mm_parsed_version) = $self->parse_version;
        $self->{VERSION} = $mm_parsed_version;

        return if $mm_parsed_version =~ /_/;

        return if $mm_parsed_version =~ m/\s/; # ignore "You suck!"

        my($ppp) = $self->ppp;  # packages-per-pmfile
        my @keys_ppp = $self->filter_ppps(keys %$ppp);
        $self->verbose(1,"will check keys_ppp[@keys_ppp]\n");

        #
        # Immediately after each package (pmfile) examined contact
        # the database
        #

        my ($package);
      DBPACK: foreach $package (@keys_ppp) {

            # What do we need? dio, fio, pmfile, time, dist, dbh, alert?
            my $pio = PAUSE::package->new(
                                          PACKAGE => $package,
                                          DBH => $dbh,
                                          DIST => $dist,
                                          PP => $ppp->{$package},
                                          TIME => $self->{TIME},
                                          PMFILE => $pmfile,
                                          FIO => $self,
                                          USERID => $self->{USERID},
                                          YAML_CONTENT => $self->{YAML_CONTENT},
                                         );

            $pio->examine_pkg;

        }                       # end foreach package

        delete $self->{DIO};    # circular reference

    }

    # package PAUSE::pmfile;
    sub ppp {
        my $self = shift;

        my $ppp;
        my $pmfile = $self->{PMFILE};
        my $filemtime = $self->{MTIME};
        my $version = $self->{VERSION};

        open my $fh, "<", "$pmfile" or die("Couldn't open $pmfile for read: $!");

        local $/ = "\n";
        my $inpod = 0;

      PLINE: while (<$fh>) {
            chomp;
            my($pline) = $_;
            $inpod = $pline =~ /^=(?!cut)/ ? 1 :
                $pline =~ /^=cut/ ? 0 : $inpod;
            next if $inpod;
            next if substr($pline,0,4) eq "=cut";

            $pline =~ s/\#.*//;
            next if $pline =~ /^\s*$/;
            last PLINE if $pline =~ /\b__(END|DATA)__\b/;

            my $pkg;

            if (
                $pline =~ m{
			 (.*)
			 \bpackage\s+
			 ([\w\:\']+)
			 \s*
			 ( $ | [\}\;] )
			}x) {
                $pkg = $2;

            }

            if ($pkg) {
                # Found something

                # from package
                $pkg =~ s/\'/::/;
                next PLINE unless $pkg =~ /^[A-Za-z]/;
                next PLINE unless $pkg =~ /\w$/;
                next PLINE if $pkg eq "main";
                next PLINE if length($pkg) > 64; #64 database
                #restriction
                $ppp->{$pkg}{parsed}++;
                $ppp->{$pkg}{infile} = $pmfile;
                if ($self->simile($pmfile,$pkg)) {
                    $ppp->{$pkg}{simile} = $pmfile;
                    $ppp->{$pkg}{version} ||= "";
                    $ppp->{$pkg}{version} ||= $version;
                    local($^W)=0;
                    $ppp->{$pkg}{version} =
                        $version
                            if $version
                                > $ppp->{$pkg}{version} ||
                                    $version
                                        gt $ppp->{$pkg}{version};
                } else {        # not simile
                    #### it comes later, it would be nonsense
                    #### to set to "undef". MM_Unix gives us
                    #### the best we can reasonably consider
                    $ppp->{$pkg}{version} =
                        $version
                            unless defined $ppp->{$pkg}{version} &&
                                length($ppp->{$pkg}{version});
                }
                $ppp->{$pkg}{filemtime} = $filemtime;
                $ppp->{$pkg}{pause_reg} = time;
            }
        }

        $fh->close;
        $ppp;
    }

    # package PAUSE::pmfile;
    { no strict; sub mm_unix_parse_version {
        my($parsefile) = @_;
        my $result;
        local *FH;
        local $/ = "\n";
        open(FH,$parsefile) or die "Could not open '$parsefile': $!";
        my $inpod = 0;
        while (<FH>) {
            $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
            next if $inpod || /^\s*#/;
            chop;
            # next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
            next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
            my $eval = qq{
              package ExtUtils::MakeMaker::_version;

              local $1$2;
              \$$2=undef; do {
                  $_
              }; \$$2
          };
            local $^W = 0;
            $result = eval($eval);
            die "Could not eval '$eval' in $parsefile: $@" if $@;
            last;
        }
        close FH;

        $result = "undef" unless defined $result;
        return $result;
    }
  }

    # package PAUSE::pmfile;
    sub parse_version {
        my $self = shift;

        use Safe;
        use strict;

        my $pmfile = $self->{PMFILE};
        my $pmcp = $pmfile;
        for ($pmcp) {
            s/([^\\](\\\\)*)@/$1\\@/g; # thanks to Raphael Manfredi for the
            # solution to escape @s and \
        }
        my($v);
        $self->disconnect; # no guarantee that the connection survives the fork!

        {

            package main; # seems necessary

            my($pid,$kid);
            die "Can't fork: $!" unless defined($pid = open($kid, "-|"));
            if ($pid) {         # parent
                $v = <$kid>;
                close $kid;
            } else {
                my($gnam,$gpw,$gid,$gmem) = getgrnam("UNSAFE"); 
                die "Could not determine GID of UNSAFE" unless $gid;
                my($uname,$upw,$uid,$ugid,$q,$c,$gcos,$udir,$ushell) =
                    getpwnam("UNSAFE");
                die "Could not determine UID of UNSAFE" unless $uid;
                $( = $gid; $) = "$gid $gid";
                $< = $> = $uid;

                # XXX Limit Resources too

                my($comp) = Safe->new("_pause::mldistwatch");
                my $eval = qq{
                  local(\$^W) = 0;
                  PAUSE::pmfile::mm_unix_parse_version("$pmcp");
                 };
                $comp->share("*PAUSE::pmfile::mm_unix_parse_version");
                # $comp->permit("require"); # no strict!
                no strict;
                local $PAUSE::Config;
                $v = $comp->reval($eval);
                warn "reval failed: $@ for eval[$eval]" if $@; # child process!!
                print $v;       # child process!!
                exit;
            }
        }
        $v = "undef" unless defined $v;

        $self->verbose(1,"pmfile[$pmfile] mm_parsed_version[$v]\n");
        $v =~ s/^\s+//;
        $v =~ s/\s+$//;

        # Until 2000-01-21 (rev. 2.269) we accepted underscores in
        # $VERSION, but Ilya had the idea that the underscore signals a
        # developer version. I believe this might be what people expect.
        # So the old code was:

        # $v =~ s/_//g; # respect 0.05_01

        # and the new code is

        return $v if $v =~ /_/;

        $v = CPAN::Version->readable($v);

        if (
            $v =~
            /^(\+?)(\d*)(\.(\d*))?/ &&
            # "$2$4" ne ''
            (
             defined $2 && length $2
             ||
             defined $4 && length $4
            )
           ) {
            my $two = defined $2 ? $2 : "";
            my $three = defined $3 ? $3 : "";
            $v = "$two$three";
        }
        return $v if $v =~ m/\s/; # ignore "You suck!"

        $v;
    }

}


=comment

Now we have a table primeur and we have a new terminology:

people in table "perms" are co-maintainers or maintainers

people in table "primeur" are maintainers

packages in table "packages" live there independently from permission
tables.

packages in table "mods" have an official owner. That one overrules
both tables "primeur" and "perms".


P1.0 If there is a registered maintainer in mods, put him into perms
     unconditionally.

P2.0 If perms knows about this package but current user is not in
     perms for this package, return.

 P2.1 but if user is primeur, go on

 P2.2 but if there is no primeur, make this user primeur

P3.0 Give this user an entry in perms now, no matter how many there are.

P4.0 Work out how packages table needs to be updated.

 P4.1 We know this package: complicated UPDATE

 P4.2 We don't know it: simple INSERT



package in packages  package in primeur
         1                   1               easy         nothing add'l to do
         0                   0               easy         4.2
         1                   0               error        4.1
         0                   1           complicated(*)   4.2

(*) This happens when a package is removed from CPAN completely.


=cut


{
    package PAUSE::package;
    use vars qw($AUTOLOAD);

    sub verbose {
        my($self,$level,@what) = @_;
        my $main = $self->{FIO};
        $main->verbose($level,@what);
    }

    sub DESTROY {}

    # package PAUSE::package;
    sub new {
        my($me) = shift;
        bless { @_ }, ref($me) || $me;
    }

    # package PAUSE::package;
    sub alert {
        my $self = shift;
        my $what = shift;
        my $fio = $self->{FIO};
        $fio->alert($what);
    }

    # package PAUSE::package;
    # return value nonsensical
    sub give_regdowner_perms {
        my $self = shift;
        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        local($dbh->{RaiseError}) = 0;
        my $sth_mods = $dbh->prepare("SELECT userid
                                      FROM   mods
                                      WHERE  modid = ?");
        warn "Going to execute [SELECT userid FROM mods WHERE modid = '$package']";
        $sth_mods->execute($package) or die "FAILED";
        if ($sth_mods->rows>0) { # make sure we regard the owner as the owner
            my($mods_userid) = $sth_mods->fetchrow_array;
            local($dbh->{RaiseError}) = 0;
            local($dbh->{PrintError}) = 0;
            my $query = "INSERT INTO perms (package, userid) VALUES (?,?)";
            my $ret = $dbh->do($query, {}, $package, $mods_userid);
            my $err = "";
            $err = $dbh->errstr unless defined $ret;
            $ret ||= "";
            $self->verbose(1,"into perms package[$package]mods_userid".
                           "[$mods_userid]ret[$ret]err[$err]\n");
        }
    }

    # perm_check: we're both guessing and setting.

    # P2.1: returns 1 if user is owner; makes him co-maintainer at the
    # same time

    # P2.0: otherwise returns false if the package is already known in
    # perms table AND the user is not among the co-maintainers

    # but if the package is not yet known in the perms table this makes
    # him co-maintainer AND returns 1

    # package PAUSE::package;
    sub perm_check {
        my $self = shift;
        my $dist = $self->{DIST};
        my $package = $self->{PACKAGE};
        my $pp = $self->{PP};
        my $dbh = $self->connect;

        my($userid) = $self->{USERID};

        my $ins_perms = "INSERT INTO perms (package, userid) VALUES ".
            "('$package', '$userid')";

        my($is_primeur) = $dbh->prepare(qq{SELECT package, userid
                                         FROM   primeur
 					 WHERE  package = ? AND userid = ?}
                                       );
        $is_primeur->execute($package,$userid);
        if ($is_primeur->rows) {

            local($dbh->{RaiseError}) = 0;
            my $ret = $dbh->do($ins_perms);
            my $err = "";
            $err = $dbh->errstr unless defined $ret;
            $ret ||= "";
            # print "(primeur)ins_perms[$ins_perms]ret[$ret]err[$err]\n";

            return 1;           # P2.1, P3.0
        }

        my($has_primeur) = $dbh->prepare(qq{SELECT package
                                          FROM  primeur
                                          WHERE package = ?});
        $has_primeur->execute($package);
        if ($has_primeur->rows == 0) {
            my($has_owner) = $dbh->prepare(qq{SELECT modid
                                        FROM mods
                                        WHERE modid = ?});
            $has_owner->execute($package);
            if ($has_owner->rows == 0) {
                # package has neither owner in mods nor maintainer in primeur
                local($dbh->{RaiseError}) = 0;
                my $ret = $dbh->do($ins_perms);
                my $err = "";
                $err = $dbh->errstr unless defined $ret;
                $ret ||= "";
                $self->verbose(1,"(ownerless)ins_perms[$ins_perms]ret[$ret]err[$err]\n");

                return 1;       # P2.2, P3.0
            }
        }

        my($sth_perms) = $dbh->prepare(qq{SELECT package, userid
                                         FROM   perms
 					 WHERE  package = ?}
                                      );
        $sth_perms->execute($package);

        if ($sth_perms->rows) {

            # we have a package that is already known

            for ($package,
                 $pp->{version},
                 $dist,
                 $pp->{infile}) {
                $_ ||= '';
            }
            my($p,$owner,@owner);
            while (($p,$owner) = $sth_perms->fetchrow_array) {
                push @owner, $owner; # array for debugging statement
            }
            if ($dist =~ /$PAUSE::mldistwatch::ISAPERL/ox) {
                # seems ok: perl is always right
            } elsif (! grep { $_ eq $userid } @owner) {
                # we must not index this and we have to inform somebody
                $self->index_status($package,
                                    $pp->{version},
                                    $pp->{infile},
                                    PAUSE::mldistwatch::Constants::EMISSPERM,
                                    qq{Not indexed because permissions missing.
Visit PAUSE and click "View Permissions" to find the legitimate maintainer(s).},
                                   );
                $self->alert(qq{not owner:
  package[$package]version[$pp->{version}]
  file[$pp->{infile}]dist[$dist]
  userid[$userid]owners[@owner]
});
                return;         # early return
            }

        } else {

            # package has no existence in perms yet, so this guy is OK

            local($dbh->{RaiseError}) = 0;
            my $ret = $dbh->do($ins_perms);
            my $err = "";
            $err = $dbh->errstr unless defined $ret;
            $ret ||= "";
            $self->verbose(1,"(uploader)ins_perms[$ins_perms]ret[$ret]err[$err]\n");

        }
        $self->verbose(1,sprintf( # just for debugging
                                 "02maybe: %-25s %10s %-16s (%s) %s\n",
                                 $package,
                                 $pp->{version},
                                 $pp->{infile},
                                 $pp->{filemtime},
                                 $dist
                                ));
        return 1;
    }

    # package PAUSE::package;
    sub connect {
        my($self) = @_;
        my $fio = $self->{FIO};
        $fio->connect;
    }

    # package PAUSE::package;
    sub disconnect {
        my($self) = @_;
        my $fio = $self->{FIO};
        $fio->disconnect;
    }


    # package PAUSE::package;
    sub examine_pkg {
        my $self = shift;

        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        my $dist = $self->{DIST};
        my $pp = $self->{PP};
        my $pmfile = $self->{PMFILE};

        # should they be cought earlier? Maybe.
        return unless $package =~ /\w/;
        return if $package =~ /:/ && $package !~ /::/;

        # set perms for registered owner in any case

        $self->give_regdowner_perms; # (P1.0)

        # Query all users with perms for this package

        return unless $self->perm_check; # (P2.0&P3.0)

        # Sanity checks

        for (
             $package,
             $pp->{version},
             $dist
            ) {
            return if /^\s*$/;  # for whatever reason I come here
            return if /\s/;     # don't screw up 02packages
        }

        $self->checkin;
        delete $self->{FIO};    # circular reference
    }

    sub update_package {
        # we come here only for packages that have opack and package

        my $self = shift;
        my $sth_pack = shift;

        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        my $dist = $self->{DIST};
        my $pp = $self->{PP};
        my $pmfile = $self->{PMFILE};
        my $fio = $self->{FIO};


        my($opack,$oldversion,$odist,$ofilemtime,$ofile) = $sth_pack->fetchrow_array;
        $self->verbose(1,"opack[$opack]oldversion[$oldversion]".
                       "odist[$odist]ofiletime[$ofilemtime]ofile[$ofile]\n");
        my $odistmtime = (stat "$MLROOT/$odist")[9];
        my $tdistmtime = (stat "$MLROOT/$dist")[9] ;
        # decrementing Version numbers are quite common :-(
        my $ok = 0;

        my $distorperlok = $dist !~ m|/perl|;
        # this dist is not named perl-something (lex ILYAZ)

        my $isaperl = $dist =~ /$PAUSE::mldistwatch::ISAPERL/ox;

        $distorperlok ||= $isaperl;
        # or it is THE perl dist

        my($something1) = $dist =~ m|/perl(.....)|;
        # or it is called perl-something (e.g. perl-ldap) AND...
        my($something2) = $odist =~ m|/perl(.....)|;
        # and we compare against another perl-something AND...
        my($oisaperl) = $odist =~ /$PAUSE::mldistwatch::ISAPERL/ox;
        # the file we're comparing with is not the perl dist

        $distorperlok ||= $something1 && $something2 &&
            $something1 eq $something2 && !$oisaperl;

        $self->verbose(1, "package[$package]infile[$pp->{infile}]".
                       "distorperlok[$distorperlok]oldversion[$oldversion]".
                       "odist[$odist]\n");

        # Until 2002-08-01 we always had
        # if >ver                                                 OK
        # elsif <ver
        # else
        #   if 0ver
        #     if <=old                                            OK
        #     else
        #   elsif =ver && <=old && ( !perl || perl && operl)      OK

        # From now we want to have the primary decision on isaperl. If it
        # is a perl, we only index if the other one is also perl or there
        # is no other. Otherwise we leave the decision tree unchanged
        # except that we can simplify the complicated last line to

        #   elsif =ver && <=old                                   OK

        # AND we need to accept falling version numbers if old dist is a
        # perl

        # relevant postings/threads:
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-07/msg01579.html
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-08/msg00062.html


        if (! $distorperlok) {
        } elsif ($isaperl) {
            if ($oisaperl) {
                if (CPAN::Version->vgt($pp->{version},$oldversion)) {
                    $ok++;
                } elsif (CPAN::Version->vgt($oldversion,$pp->{version})) {
                } elsif (CPAN::Version->vcmp($pp->{version},$oldversion)==0
                         &&
                         $tdistmtime >= $odistmtime) {
                    $ok++;
                }
            } else {
                if (CPAN::Version->vgt($pp->{version},$oldversion)) {
                    $self->index_status($package,
                                        $pp->{version},
                                        $pp->{infile},
                                        PAUSE::mldistwatch::Constants::EDUALOLDER,

                                        qq{Not indexed because $ofile
 seems to have a dual life in $odist. Although the other package is at
 version [$oldversion], the indexer lets the other dist continue to be
 the reference version, shadowing the one in the core. Maybe harmless,
 maybe needs resolving.},

                                   );
                } else {
                    $self->index_status($package,
                                        $pp->{version},
                                        $pp->{infile},
                                        PAUSE::mldistwatch::Constants::EDUALYOUNGER,

                                        qq{Not indexed because $ofile
 has a dual life in $odist. The other version is at $oldversion, so
 not indexing seems okay.},

                                   );
                }
            }
        } elsif (CPAN::Version->vgt($pp->{version},$oldversion)) {
            # higher VERSION here
            $self->verbose(1, "$package version better ".
                           "[$pp->{version} > $oldversion] $dist wins\n");
            $ok++;
        } elsif (CPAN::Version->vgt($oldversion,$pp->{version})) {
            # lower VERSION number here
            if ($odist ne $dist) {
                $self->index_status($package,
                                    $pp->{version},
                                    $pmfile,
                                    PAUSE::mldistwatch::Constants::EVERFALLING,
                                    qq{Not indexed because $ofile in $odist
has a higher version number ($oldversion)},
                                   );
                $self->alert(qq{falling VERSION number [$pp->{version}]
 in package[$package]
 dist[$dist]
 oldversion[$oldversion]
 pmfile[$pmfile]
}); # });
            } elsif ($oisaperl) {
                $ok++;          # new on 2002-08-01
            }
        } else {

            if (                # no version here,
                $pp->{version} == 0
               ) {
                if (            # but younger or same-age file
                    $pp->{filemtime} >= $ofilemtime
                   ) {
                    $self->verbose(1, "$package noversion comp $dist vs $odist: >=\n");
                    $ok++;
                } else {

                    $self->verbose(1, "ALERT: Not updating! $package noversion ".
                                   "falling mtime
filemtime[$pp->{filemtime}]ofilemtime[$ofilemtime]\n");

                    $self->index_status(
                                        $package,
                                        $pp->{version},
                                        $pp->{infile},
                                        PAUSE::mldistwatch::Constants::EMTIMEFALLING,
                                        qq{Not indexed because $ofile in $odist
has a more recent modification time.},
                                       );
                    # no version and strange timestamps.

                }

            } elsif (
                     # equal version here
                     CPAN::Version->vcmp($pp->{version},$oldversion)==0
                    ) {
                $self->verbose(1, "$package version eq comp $dist vs $odist\n");
                if ($tdistmtime >= $odistmtime) {
                    $ok++;
                } else {
                    $self->index_status(
                                        $package,
                                        $pp->{version},
                                        $pp->{infile},
                                        PAUSE::mldistwatch::Constants::EOLDRELEASE,
                                        qq{Not indexed because $ofile in $odist
has the same version number and the distro has a more recent modification time.}
                                       );
                }
            } else {
                $self->verbose(1, "Nothing interesting in dist[$dist]package[$package]\n");
            }
        }


        if ($ok) {              # sanity check

            if (! $pp->{simile}
                &&
                $fio->simile($ofile,$package)
               ) {
                $self->verbose(1,
                               "Warning: we are not simile AND we have been ".
                               "simile some time earlier:\n");
                $self->verbose(1,Data::Dumper::Dumper($pp), "\n");
                $ok = 0;
            }
        }

        if ($ok) {

            my $query = qq{UPDATE packages SET
version       = '$pp->{version}',
dist          = '$dist',
file          = '$pp->{infile}',
filemtime     = '$pp->{filemtime}',
pause_reg     = '$self->{TIME}'
WHERE package = '$package'
};
            $self->verbose(1,"Q: [$query]\n");
            $dbh->do($query);
            $self->index_status($package,
                                $pp->{version},
                                $pp->{infile},
                                PAUSE::mldistwatch::Constants::OK,
                                "indexed",
                               );

        }

    }

    # package PAUSE::package;
    sub index_status {
        my($self) = shift;
        my $fio = $self->{FIO};
        my $dio = $fio->{DIO};
        $dio->index_status(@_);
    }

    # package PAUSE::package;
    sub insert_into_package {
        my $self = shift;
        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        my $dist = $self->{DIST};
        my $pp = $self->{PP};
        my $pmfile = $self->{PMFILE};
        $self->verbose(1,"First time here, eh?\n");
        my $query = qq{INSERT INTO packages
 (package, version, dist, file, filemtime, pause_reg)
VALUES (
	'$package',
	'$pp->{version}',
	'$dist',
	'$pp->{infile}',
	'$pp->{filemtime}',
	'$self->{TIME}'
       )
};
        $self->verbose(1,"Q: [$query]\n");
        $dbh->do($query);
        $self->index_status($package,
                            $pp->{version},
                            $pp->{infile},
                            PAUSE::mldistwatch::Constants::OK,
                            "indexed",
                           );
    }

    # package PAUSE::package;
    # returns always the return value of print, so basically always 1
    sub checkin_into_primeur {
        my $self = shift;
        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        my $dist = $self->{DIST};
        my $pp = $self->{PP};
        my $pmfile = $self->{PMFILE};

        # we cannot do that yet, first we must fill primeur with the
        # values we believe are correct now.

        # We come here, no matter if this package is in primeur or not. We
        # know, it must get in there if it isn't yet. No update, just an
        # insert, please. Should be similar to give_regdowner_perms(), but
        # this time with this user.

        # print ">>>>>>>>checkin_into_primeur not yet implemented<<<<<<<<\n";

        local($dbh->{RaiseError}) = 0;
        local($dbh->{PrintError}) = 0;

        my $userid = $self->{USERID} or die;
        my $query = "INSERT INTO primeur (package, userid) VALUES (?,?)";
        my $ret = $dbh->do($query, {}, $package, $userid);
        my $err = "";
        $err = $dbh->errstr unless defined $ret;
        $ret ||= "";
        $self->verbose(1,
                       "into primeur package[$package]userid[$userid]ret[$ret]".
                       "err[$err]\n");
    }

    # package PAUSE::package;
    sub checkin {
        my $self = shift;
        my $dbh = $self->connect;
        my $package = $self->{PACKAGE};
        my $dist = $self->{DIST};
        my $pp = $self->{PP};
        my $pmfile = $self->{PMFILE};

        $self->checkin_into_primeur; # called in void context!

        my $sth_pack = $dbh->prepare(qq{SELECT package, version, dist,
			                  filemtime, file
                                   FROM packages
                                   WHERE package = ?});

        $sth_pack->execute($package);


        if ($sth_pack->rows) {

            # We know this package from some time ago

            $self->update_package($sth_pack);

        } else {

            # we hear for the first time about this package

            $self->insert_into_package;

        }

    }
}

MAIN: {
    umask 0002;
    $|=1;

    my %Opt;
    GetOptions(
               \%Opt,
               "pick=s@", # the idea is to NOT run find if they tell us
                      # one distro, but this needs careful thinking to
                      # not delete the whole database at some point.
                      # So currently all that "pick" does is, it
                      # suppresses writing of 0[123]* files.
              );
    my $mldw = PAUSE::mldistwatch->new(\%Opt);
    $mldw->work;
}

exit;


__END__

=pod

+---------------------------------------------------------------+
| We run through the whole filesystem and check for new files   |
| and for goners.                                               |
+---------------------------------------------------------------+
| We compare them with the database of distribution files and   |
| decide if we have to examine them closer. We also create a    |
| trivial "database" of CHECKSUMS in the same directory as a    |
| distro resides.                                               |
+---------------------------------------------------------------+
| We unzip new files into a tree and examine files in that tree |
| and compare these with data about packages in the database.   |
+---------------------------------------------------------------+
| During the course we write mails.			        |
+---------------------------------------------------------------+
| When we are done, we create summaries from the database.      |
+---------------------------------------------------------------+

So we have distfilechecks, directorychecks and contentfilechecks.
Contentchecks have two parts, files and namespaces (packages). And we
have some sort of a scheduler that keeps track of what we have to do.

4 levels of classes:

PAUSE::mldistwatch       we could call it main. One object does all the
                         work

PAUSE::mldistwatch::Constants
                         constants used for PAUSE::dist::index_status()

PAUSE::dist              each distro we find is an object of this class

PAUSE::pmfile            each *.pm file in each distro is one object of
                         this class

PAUSE::package           each package statement per pm-file is an object
                         of this class


The methods alert() and verbose() exist in all classes. Only the two
in PAUSE::mldistwatch do something for real, the others just pass
their arguments up in the "stack" of objects. Similarly index_status
passes arguments up till they reach the PAUSE::dist object. From there
they are harvested in the mail_summary() method that sends a report to
the owner of the package

=cut
